{"version":3,"sources":["webpack:///webpack/bootstrap 1a4bade1876df24b2f48","webpack:///./~/node-event-emitter/index.js","webpack:///./phrase-matcher/script.js"],"names":["EventEmitter","require","SpeechRecognition","webkitSpeechRecognition","SpeechGrammarList","webkitSpeechGrammarList","SpeechRecognitionEvent","webkitSpeechRecognitionEvent","phrases","phrasePara","document","querySelector","diagnosticPara","testBtn","counter","nextPhrase","ee","testSpeech","disabled","textContent","phrase","grammar","recognition","speechRecognitionList","addFromString","grammars","lang","interimResults","maxAlternatives","start","speaking","onresult","event","speechResult","results","transcript","console","log","confidence","onspeechend","stop","emit","onerror","error","addEventListener"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA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","file":"./phrase-matcher/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1a4bade1876df24b2f48","/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n}\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n}\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-event-emitter/index.js\n// module id = 0\n// module chunks = 0","const EventEmitter = require('node-event-emitter');\n\nvar SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;\nvar SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList;\nvar SpeechRecognitionEvent = SpeechRecognitionEvent || webkitSpeechRecognitionEvent;\n\nvar phrases = [\n  'A very young Mouse, who had never seen anything of the world, almost came to grief the very first time he ventured out.',\n  'And this is the story he told his mother about his adventures.'\n]\n\nvar phrasePara = document.querySelector('.phrase');\nvar diagnosticPara = document.querySelector('.output');\n\nvar testBtn = document.querySelector('button');\n\nvar counter = -1\nfunction nextPhrase() {\n  counter++\n  return counter\n}\nconst ee = new EventEmitter()\n\nfunction testSpeech() {\n  testBtn.disabled = true;\n  testBtn.textContent = 'Test in progress';\n\n  var phrase = phrases[nextPhrase()];\n  phrasePara.textContent = phrase;\n\n  var grammar = '#JSGF V1.0; grammar phrase; public <phrase> = ' + phrase +';';\n  var recognition = new SpeechRecognition();\n  var speechRecognitionList = new SpeechGrammarList();\n  speechRecognitionList.addFromString(grammar, 1);\n  recognition.grammars = speechRecognitionList;\n  recognition.lang = 'en-US';\n  recognition.interimResults = true;\n  recognition.maxAlternatives = 1;\n\n  recognition.start();\n\n  \n  // const subj = new Rx.FuncSubject()  // Maybe that's what it's called\n  let speaking = ''\n  recognition.onresult = function(event) {\n    // The SpeechRecognitionEvent results property returns a SpeechRecognitionResultList object\n    // The SpeechRecognitionResultList object contains SpeechRecognitionResult objects.\n    // It has a getter so it can be accessed like an array\n    // The first [0] returns the SpeechRecognitionResult at position 0.\n    // Each SpeechRecognitionResult object contains SpeechRecognitionAlternative objects that contain individual results.\n    // These also have getters so they can be accessed like arrays.\n    // The second [0] returns the SpeechRecognitionAlternative at position 0.\n    // We then return the transcript property of the SpeechRecognitionAlternative object \n    var speechResult = event.results[0][0].transcript;\n    diagnosticPara.textContent = 'Speech received: ' + speechResult + '.';\n    speaking = speechResult\n    // With eventemitters\n    // ee.emit('speech', event)\n\n    // With Rx\n    // subj(event)\n\n    console.log(speechResult)\n\n    console.log('Confidence: ' + event.results[0][0].confidence);\n  }\n\n\n  // return subj\n\n  recognition.onspeechend = function() {\n    recognition.stop();\n    testBtn.disabled = false;\n    testBtn.textContent = 'Start new test';\n    ee.emit('speech', speaking) \n  }\n\n  recognition.onerror = function(event) {\n    testBtn.disabled = false;\n    testBtn.textContent = 'Start new test';\n    diagnosticPara.textContent = 'Error occurred in recognition: ' + event.error;\n  }\n\n}\n\ntestBtn.addEventListener('click', testSpeech);\n\nexport default ee\n  \n// const recognizer = Speech.recognize()\n//     , analyzer = Speech.analyze()\n\n// recognizer\n//   .on('speech', speech => analyzer.findEntities(speech).on('entities', console.log))\n\n// .map(speech => analyzer.findEntities(speech))\n//  .subscribe(console.log)\n\n\n// WEBPACK FOOTER //\n// ./phrase-matcher/script.js"],"sourceRoot":""}